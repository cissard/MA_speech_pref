---
title: "How does the human auditory system become expert in speech processing? Insights from development."
author: "Cécile Issard and Alejandrina Cristia"
date: "15/5/2019"
output: pdf_document
#bibliography: bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
A long line of research shows that infants process speech preferentially over other types of sounds. As the main signal for vocal communication, speech must be special for humans. Readily from birth, humans would be equipped with an auditory module dedicated to speech sounds, to process them with dedicated auditory and cognitive mechanisms. This preference has been investigated by numerous studies, contrasting speech to a variety of sounds, from white noise to backward speech, and at different ages. Getting a precise overview of this capacity is therefore difficult. 
“broader template that initially encompasses vocalizations of human and nonhuman primates and is rapidly tuned specifically to human vocalizations.” “Is this link sufficiently broad to include naturalistic vocalizations beyond those of our closest genealogical cousins, or is it restricted to primates, whose vocalizations may be perceptually just close enough to our own to serve as early candidates for the platform on which human language is launched?” (Ferry et al., 2013) 
The auditory literature suggests that natural sounds are processed differently by the auditory system (e.g. Mezhrahi & Nelken, 2014). Extending to language acquisition, naturalness is a key factor for word segmentation (Black and Bergman, 2016). Speech might therefore not be prefered per se, but because it belongs to a broader category of natural, own-species, or communicative sounds.

	To answer this question, we conducted a meta-analysis investigating infants’ preference for speech sounds over other types of sounds. We looked for studies  through reference lists inspection, google scholar alerts for the words “ "infant-directed speech" acoustics ”, google scholar searches (“("speech preference" OR "own-species vocalization" ) AND infant”, and “("speech preference" OR "own-species vocalization" ) AND infant”). We included studies that tested human infants for birth to 1 year (0-365 days) of age, and contrasted speech sounds with any other type of sound, measuring either behavioral (e.g. looking times) or neurophysiological responses to the sounds. We excluded studies that contrasted foreign to native language, or didn’t present natural speech sounds. A PRISMA flowchart summarizing the literature review and selection process is available here. We documented all the studies that we inspected in this decision spreadsheet.
	We coded the familiarity with the language used (native/foreign), the naturalness of the contrastive sound (natural/artificial) as moderators, and when it was natural whether the contrastive sound was social or not, and whether it was from another species.

```{r, setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache = TRUE) #option for all the code chunks of the document.
ggplot2::theme_set(langcog::theme_mikabr(base_family = "Ubuntu"))

source("/Users/etudiantmac06/Documents/MA_speech_pref/compute_es.R", chdir = TRUE)  #chdir stands for "change directory"

library(metafor)
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)
library(purrr)
library(langcog)
library(grid)
library(gridExtra)

```

```{r db general}

DB <- read.csv("MA_speech_pref_data.csv", header = T, sep = ",", na.strings = "")

#no of datapoints and variables coded
dim(DB)

#unique studies
levels(factor(DB$short_cite))

#number of unique infants
DB$n<-rowSums( cbind (DB$n_1,DB$n_2), na.rm=TRUE)
temp<-aggregate(n~same_infant,DB,mean)
sum(temp$n)

summary(DB$mean_age_1)

```

```{r correlations for within participant designs, include=FALSE}
#calculate correlations
for (i in 1:nrow(DB)){
    db = DB[i,]
       if (db$participant_design == "within_two") {
        # Use raw means, SD, and t-values to calculate correlations
          if (is.na(db$corr) & complete(db$x_1, db$x_2, db$SD_1, db$SD_2, db$t)) {
        db$corr = (db$SD_1^2 + db$SD_2^2 - (db$n_1 * (db$x_1 - db$x_2)^2 / db$t^2)) / (2 * db$SD_1 * db$SD_2)
          }
        DB[i,] = db
       }
}

#if all of these measures are not reported, use an imputed correlation value
#we also account for the observation that some re-calculated values are impossible and replace those
for (i in 1:nrow(DB)){
    db = DB[i,]
       if (db$participant_design == "within_two") {
         if (is.na(db$corr) | db$corr > .99 | db$corr < .01){
          db$corr = runif(1, min = 0.01, max = 0.99)
         }
       DB[i,] = db
       }
}
```

```{r individual_es, include=FALSE}
#We create variables for effect sizes (ES)
DB$d_calc = NA
DB$d_var_calc = NA
DB$g_calc = NA
DB$g_var_calc = NA
DB$r_calc = NA
DB$r_var_calc = NA
DB$z_calc = NA
DB$z_var_calc = NA
DB$log_odds_calc = NA
DB$log_odds_var_calc = NA
DB$es_method = NA
  
#we introduce variables calles d_calc and d_var_calc to distiguish them from the fields d and d_var, which are fields where effect sizes were already available from the source of the data
  d_calc <- NA
  d_var_calc <- NA
  es_method <- "missing"

#start of decision tree where effect sizes are calculated differently based on participant design depending on which data is available, effect sizes are calculated differently
  for (i in 1:nrow(DB)){
    db = DB[i,]
       if (db$participant_design == "between") {
    es_method  <- "between"
    #effect size calculation
    if (complete(db$x_1, db$x_2, db$SD_1, db$SD_2)) {
      pooled_SD <- sqrt(((db$n_1 - 1) * db$SD_1 ^ 2 + (db$n_2 - 1) * db$SD_2 ^ 2) / (db$n_1 + db$n_2 - 2)) # Lipsey & Wilson, 3.14
      d_calc <- (db$x_1 - db$x_2) / pooled_SD # Lipsey & Wilson (2001)
    } else if (complete(db$t)) {
      d_calc <- db$t * sqrt((db$n_1 + db$n_2) / (db$n_1 * db$n_2)) # Lipsey & Wilson, (2001)
    } else if (complete(db$F)) {
      d_calc <- sqrt(db$F * (db$n_1 + db$n_2) / (db$n_1 * db$n_2)) # Lipsey & Wilson, (2001)
    } else {d_calc = NA}
    #now that effect size are calculated, effect size variance is calculated
    if (complete(db$n_1, db$n_2, d_calc)) {
      d_var_calc <- ((db$n_1 + db$n_2) / (db$n_1 * db$n_2)) + (d_calc ^ 2 / (2 * (db$n_1 + db$n_2)))
    } else if (complete(db$d, db$d_var)) {
      #if d and d_var were already reported, use those values
      d_calc <- d
      d_var_calc <- d_var
    }

  } else if (db$participant_design == "within_two") {
      
    #effect size calculation
    if (complete(db$x_1, db$x_2, db$SD_1, db$SD_2)) {
      pooled_SD <- sqrt((db$SD_1 ^ 2 + db$SD_2 ^ 2) / 2) # Lipsey & Wilson (2001)
      d_calc <- (db$x_1 - db$x_2) / pooled_SD # Lipsey & Wilson (2001)
      es_method  <- "group_means_two"
    } else if (complete(db$t)) {
      wc <- sqrt(2 * (1 - db$corr))
      d_calc <- (db$t / sqrt(db$n_1)) * wc #Dunlap et al., 1996, p.171
      es_method  <- "t_two"
    } else if (complete(db$F)) {
      wc <- sqrt(2 * (1 - db$corr))
      d_calc <- sqrt(db$F / db$n_1) * wc
      es_method  <- "f_two"
    } else {d_calc = NA}
    #now that effect size are calculated, effect size variance is calculated
    if (complete(db$n_1, d_calc)) {
      #d_var_calc <- ((1 / n_1) + (d_calc ^ 2 / (2 * n_1))) * 2 * (1 - corr) #we used this until 4/7/17
      d_var_calc <- (2 * (1 - db$corr)/ db$n_1) + (d_calc ^ 2 / (2 * db$n_1)) # Lipsey & Wilson (2001)
    } else if (complete(db$d, db$d_var)) {
      #if d and d_var were already reported, use those values
      d_calc <- db$d
      d_var_calc <- db$d_var
      es_method  <- "d_two"
    }
  } else if (db$participant_design == "within_one") {
    if (complete(db$x_1, db$x_2, db$SD_1)) {
      d_calc <- (db$x_1 - db$x_2) / db$SD_1
      es_method  <- "group_means_one"
    } else if (complete(db$t)) {
      d_calc <- db$t / sqrt(db$n_1)
      es_method  <- "t_one"
    } else if (complete(db$F)) {
      d_calc <- sqrt(db$F / db$n_1)
      es_method  <- "f_one"
    } else {d_calc = NA}
  }
  
  df <- if (db$participant_design == "between") {
    sum(db$n_1, db$n_2, na.rm = TRUE) - 2
  } else {
    db$n_1 - 1
  }
  J <- 1 - 3 / (4 * (df - 1))
  g_calc <- d_calc * J
  g_var_calc <- J ^ 2 * d_var_calc

  if (db$participant_design == "between") {
    a <- (sum(db$n_1, db$n_2, na.rm = TRUE) ^ 2) / prod(db$n_1, db$n_2, na.rm = TRUE)
  } else {
    a <- 4
  }
  r_calc <- d_calc / sqrt(d_calc ^ 2 + a)
  r_var_calc <- a ^ 2 * d_var_calc / (d_calc ^ 2 + a) ^ 3

  z_calc <- 0.5 * log((1 + r_calc) / (1 - r_calc))
  z_var_calc = 1 / (db$n_1 - 3)

  log_odds_calc <- d_calc * pi / sqrt(3)
  log_odds_var_calc <- d_var_calc * pi ^ 2 / 3
  
  #add the results to the database
  db$d_calc = d_calc
  db$d_var_calc = d_var_calc
  db$g_calc = g_calc
  db$g_var_calc = g_var_calc
  db$r_calc = r_calc
  db$r_var_calc = r_var_calc
  db$z_calc = z_calc
  db$z_var_calc = z_var_calc
  db$log_odds_calc = log_odds_calc
  db$log_odds_var_calc = log_odds_var_calc
  db$es_method = es_method
  
  DB[i,] = db
  }

#Mark effect sizes more than 3 SD away from the mean effect (in both positive and negative directions) as outliers
DB$outlier <- NA
for (i in 1:nrow(DB)){
   db = DB[i,]
   if (db$d_calc > (mean(DB$d_calc, na.rm = TRUE) + 3*sd(DB$d_calc, na.rm = TRUE)) 
                         | db$d_calc < (mean(DB$d_calc, na.rm = TRUE) - 3*sd(DB$d_calc, na.rm = TRUE) ))
   {db$outlier = T}
   else if (db$d_calc < (mean(DB$d_calc, na.rm = TRUE) + 3*sd(DB$d_calc, na.rm = TRUE) 
                         & db$d_calc > mean(DB$d_calc, na.rm = TRUE) - 3*sd(DB$d_calc, na.rm = TRUE) ))
   {db$outlier = F}
   DB[i,] = db
}

# save the complete data base
write.csv(DB,'speech_pref_full_DB.csv')

#info 
paste("We were considering", nrow(DB),"ES candidates")
paste("We could calculate", sum(!is.na(DB$d_calc)),"ES's")

#summarize the data
mean(DB$d_calc,na.rm=T)
sd(DB$d_calc,na.rm=T)
hist(DB$d_calc, main = )
```

Sho: We assess significance of predictor variables by model comparison.
To this end, we first create a base model, including moderators that influence ES apart from target moderators. This base model includes
- infant age
We include random effects of paper (short_cite), and random effects for independent infants within paper (same_infant).
We use method="ML", which is appropriate for model comparison
```{r predictors}

#setting up of predictors
db$test_lang<-factor(db$naturalness)
db$species<-factor(db$species)
db$social<-factor(db$social)
#contrast coding for naturalness: each level is compared to the overall mean of the dependent variable, intercept corresponds to the mean of cell means
#http://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/
contrasts(db1$naturalness)=contr.sum(2) 
#contrast coding for species and social as well
contrasts(db1$species)<-contr.sum(2)
contrasts(db1$social)<-contr.sum(2)

#centering of age (although some rows also have mean_age_2, it is always the same as mean_age_1 in this db, hence the latter is used)

db1$agec<-scale(db1$mean_age_1,scale=F)
```

## Including Plots

```{r Figure Template}

apatheme=theme_bw()+
  theme(#panel.grid.major=element_blank(),
        #panel.grid.minor=element_blank(),
        panel.border=element_blank(),
        axis.line=element_line(),
        #text=element_text(family='Times'),
        legend.position='none')
```

# Spectral and temporal analysis, full model
In our first analysis on the influence of spectral/temporal distance, we base our analysis on all datapoints that have associated spectral or temporal distance reported, respectively.  Only spectral distance shows significant differences compared to the base model.
```{r full model}

#Since studies differ in whether they report spectral and/or temporal difference, we created separate base models including the respective subset of data points.
base.spec.full<-rma.mv(g_calc, g_var_calc, mods=~ test_lang*agec + exposure_phase,random = ~ 1 | short_cite/same_infant, data=db1[!is.na(db1$specdif),], weighted=TRUE, method = "ML")

base.length.full<-rma.mv(g_calc, g_var_calc, mods=~ test_lang*agec + exposure_phase,random = ~ 1 | short_cite/same_infant, data=db1[!is.na(db1$tdif),], weighted=TRUE, method = "ML")


#full models
specdif.full<-rma.mv(g_calc, g_var_calc, mods=~ specdif*test_lang*agec + exposure_phase,random = ~ 1 | short_cite/same_infant, data=db1, weighted=TRUE, method = "ML")

lengthdif.full<-rma.mv(g_calc, g_var_calc, mods=~ tdif*test_lang*agec + exposure_phase,random = ~ 1 | short_cite/same_infant, data=db1, weighted=TRUE, method = "ML")

#model comparison
anova(base.spec.full, specdif.full)
anova(base.length.full,lengthdif.full)

#model summaries
summary(specdif.full)
summary(lengthdif.full)


#Figures
sp.full<-ggplot(db1[!is.na(db1$specdif),], aes(x=specdif,y=g_calc)) + ggtitle("Spectral distance")+ theme_bw() +
  geom_point(col="turquoise", aes(size = 1/g_var_calc))+
  xlab("Spectral difference in bark")+
  ylab("Hedge's g")+
  geom_abline(intercept = specdif.full$b[1], slope = specdif.full$b[2],size=1.5, col="grey")+
  apatheme +
  theme(text = element_text(size=16)) 

tp.full<-ggplot(db1[!is.na(db1$tdif),], aes(x=tdif,y=g_calc)) + ggtitle("Temporal distance")+ theme_bw() +
  geom_point(col="indianred1", aes(size = 1/g_var_calc))+
  xlab("Temporal difference ratio")+
  ylab("Hedge's g")+
  geom_abline(intercept = lengthdif.full$b[1], slope = lengthdif.full$b[2],size=1.5,col="grey")+
  apatheme +
  theme(text = element_text(size=16)) 

pdf("Fig2.pdf",width=10,height=6)
grid.arrange(sp.full, tp.full,ncol=2)
dev.off()

# 
# specdif.full.age<-rma.mv(g_calc, g_var_calc, mods=~ specdif*test_lang*mean_age_1 + exposure_phase,random = ~ 1 | short_cite/same_infant, data=db1, weighted=TRUE, method = "ML")
# lengthdif.full.age<-rma.mv(g_calc, g_var_calc, mods=~ tdif*test_lang*mean_age_1 + exposure_phase,random = ~ 1 | short_cite/same_infant, data=db1, weighted=TRUE, method = "ML")
# 
# sp.age<-ggplot(db1[!is.na(db1$specdif),], aes(x=mean_age_1,y=g_calc)) + ggtitle("Age (spectral set)")+ theme_bw() +
#   geom_point(col="turquoise", aes(size = 1/g_var_calc))+
#   xlab("Age in days")+
#   ylab("Hedge's g")+
#   geom_abline(intercept = specdif.full.age$b[1], slope = specdif.full.age$b[4],size=1.5,col="grey")+
#   apatheme +
#   theme(text = element_text(size=16))
# 
# tp.age<-ggplot(db1[!is.na(db1$tdif),], aes(x=mean_age_1,y=g_calc)) + ggtitle("Age (temporal set)")+ theme_bw() +
#   geom_point(col="indianred1", aes(size = 1/g_var_calc))+
#   xlab("Age in days")+
#   ylab("Hedge's g")+
#   geom_abline(intercept = lengthdif.full.age$b[1], slope = lengthdif.full.age$b[4],size=1.5,col="grey")+
#   apatheme +
#   theme(text = element_text(size=16))

# pdf("Fig2_alt.pdf")
# grid.arrange(sp.full, tp.full,sp.age,tp.age,ncol=2)
# dev.off()

#base.feat.full1<-rma.mv(g_calc, g_var_calc, mods=~ test_lang*agec + exposure_phase,random = ~ 1 | short_cite/same_infant,data=db1[!is.na(db1$featdif),], weighted=TRUE, method = "ML")
#featdif.full<-rma.mv(g_calc, g_var_calc, mods=~ featdif*test_lang*agec + exposure_phase ,random = ~ 1 | /same_infant, data=db1, weighted=TRUE, method = "ML")
# ggplot(db1[!is.na(db1$featdif),], aes(x=factor(featdif),y=g_calc,fill=factor(featdif))) + ggtitle("Feature difference")+ theme_bw() +
#   geom_boxplot() + 
#   geom_jitter(position=position_jitterdodge(dodge.width=0.9), stat = "identity",  aes(factor(featdif),g_calc,size = 1/g_var_calc))


```
